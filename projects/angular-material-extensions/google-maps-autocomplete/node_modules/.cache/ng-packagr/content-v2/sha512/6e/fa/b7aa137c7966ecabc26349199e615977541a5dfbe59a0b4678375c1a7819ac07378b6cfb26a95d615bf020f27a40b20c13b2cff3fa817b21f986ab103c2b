{"hash":"7b7e2a18ca11798e7d4f393f862f27403793d49d","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { forwardRef, Directive, EventEmitter, Component, ViewChild, Input, Output, PLATFORM_ID, Inject, HostListener, NgModule } from '@angular/core';\nimport * as i1$1 from '@angular/forms';\nimport { NG_VALIDATORS, FormControl, Validators, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport * as i1 from '@agm/core';\nimport * as i2 from '@angular/material/form-field';\nimport * as i3 from '@angular/material/input';\nimport { MatInputModule } from '@angular/material/input';\nimport * as i6 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { animation, style, animate, trigger, transition, useAnimation, state, query, stagger, animateChild } from '@angular/animations';\nimport { distinctUntilChanged, debounceTime, takeUntil } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport * as i3$1 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i4 from '@angular/flex-layout/flex';\nimport { FlexLayoutModule } from '@angular/flex-layout';\n\nfunction parseGermanAddress(placeResult) {\n    const germanAddress = {\n        gmID: placeResult.id,\n        icon: placeResult.icon,\n        url: placeResult.url,\n        placeID: placeResult.place_id,\n        displayAddress: placeResult.formatted_address,\n        name: placeResult.name,\n        vicinity: placeResult.vicinity,\n        locality: {},\n        state: {},\n        country: {},\n        geoLocation: { latitude: -1, longitude: -1 },\n    };\n    if (placeResult.geometry && placeResult.geometry.location) {\n        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n    }\n    if (placeResult.address_components && placeResult.address_components.length > 0) {\n        placeResult.address_components.forEach(value => {\n            if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n            }\n            if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n            }\n            if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n            }\n            if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n            }\n            if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n            }\n            if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n            }\n        });\n    }\n    return germanAddress;\n}\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\nclass MatValidateAddressDirective {\n    constructor() {\n    }\n    validate() {\n        return (control) => {\n            return this.address ? null : {\n                validateAddress: {\n                    valid: false\n                }\n            };\n        };\n    }\n    subscribe(eventEmitter) {\n        this.subscription = eventEmitter.subscribe((address) => {\n            this.address = address;\n        });\n    }\n    unsubscribe() {\n        this.subscription.unsubscribe();\n    }\n    get address() {\n        return this._address;\n    }\n    set address(value) {\n        this._address = value;\n    }\n}\nMatValidateAddressDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatValidateAddressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nMatValidateAddressDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\", providers: [\n        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n    ], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatValidateAddressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n                    providers: [\n                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });\n\nvar Appearance;\n(function (Appearance) {\n    Appearance[\"STANDARD\"] = \"standard\";\n    Appearance[\"FILL\"] = \"fill\";\n    Appearance[\"OUTLINE\"] = \"outline\";\n    Appearance[\"LEGACY\"] = \"legacy\";\n})(Appearance || (Appearance = {}));\nclass MatGoogleMapsAutocompleteComponent {\n    constructor(mapsAPILoader, ngZone) {\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n        this.addressLabelText = 'Address';\n        this.placeholderText = 'Please enter the address';\n        this.requiredErrorText = 'The address is required';\n        this.invalidErrorText = 'The address is not valid';\n        this.appearance = Appearance.STANDARD;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.addressValidator = new MatValidateAddressDirective();\n        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([\n            Validators.required,\n            this.addressValidator.validate()\n        ]));\n        this.propagateChange = (_) => {\n        };\n    }\n    ngOnInit() {\n        this.addressValidator.subscribe(this.onNewPlaceResult);\n        const options = {\n            // types: ['address'],\n            // componentRestrictions: {country: this.country},\n            placeIdOnly: this.placeIdOnly,\n            strictBounds: this.strictBounds,\n            // types: this.types,\n            type: this.type\n        };\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.componentRestrictions = { country: this.country } : null;\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.types = this.types : null;\n        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n        this.initGoogleMapsAutocomplete();\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach(value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    });\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                        this.value = place;\n                        this.propagateChange(this.value);\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    // console.log('onAutocompleteSelected -> ', place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    onQuery(event) {\n        // console.log('onChange()', event);\n        this.onChange.emit(this.address);\n    }\n    resetAddress() {\n        this.address = null;\n        this.addressSearchControl.updateValueAndValidity();\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n        throw new Error('Method not implemented.');\n    }\n    setDisabledState(isDisabled) {\n        throw new Error('Method not implemented.');\n    }\n}\nMatGoogleMapsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i1.MapsAPILoader }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\nMatGoogleMapsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatGoogleMapsAutocompleteComponent, selector: \"mat-google-maps-autocomplete\", inputs: { addressLabelText: \"addressLabelText\", placeholderText: \"placeholderText\", requiredErrorText: \"requiredErrorText\", invalidErrorText: \"invalidErrorText\", appearance: \"appearance\", value: \"value\", address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n            multi: true\n        }\n    ], viewQueries: [{ propertyName: \"searchElementRef\", first: true, predicate: [\"search\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0, template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"], components: [{ type: i2.MatFormField, selector: \"mat-form-field\", inputs: [\"color\", \"appearance\", \"hideRequiredMarker\", \"hintLabel\", \"floatLabel\"], exportAs: [\"matFormField\"] }], directives: [{ type: i2.MatLabel, selector: \"mat-label\" }, { type: i3.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\" }, { type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { type: i1$1.NgModel, selector: \"[ngModel]:not([formControlName]):not([formControl])\", inputs: [\"name\", \"disabled\", \"ngModel\", \"ngModelOptions\"], outputs: [\"ngModelChange\"], exportAs: [\"ngModel\"] }, { type: i6.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i2.MatError, selector: \"mat-error\", inputs: [\"id\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: i1.MapsAPILoader }, { type: i0.NgZone }]; }, propDecorators: { searchElementRef: [{\n                type: ViewChild,\n                args: ['search']\n            }], addressLabelText: [{\n                type: Input\n            }], placeholderText: [{\n                type: Input\n            }], requiredErrorText: [{\n                type: Input\n            }], invalidErrorText: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }] } });\n\nconst customAnimation = animation([\n    style({\n        opacity: '{{opacity}}',\n        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n], {\n    params: {\n        duration: '200ms',\n        delay: '0ms',\n        opacity: '0',\n        scale: '1',\n        x: '0',\n        y: '0',\n        z: '0'\n    }\n});\nconst InputAnimations = [\n    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n    trigger('animateStagger', [\n        state('50', style('*')),\n        state('100', style('*')),\n        state('200', style('*')),\n        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),\n        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),\n        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))\n    ]),\n];\n\nclass MatGoogleMapsAutocompleteDirective {\n    constructor(platformId, \n    // @Optional() @Self() public ngControl: NgControl,\n    elemRef, mapsAPILoader, cf, ngZone) {\n        this.platformId = platformId;\n        this.elemRef = elemRef;\n        this.mapsAPILoader = mapsAPILoader;\n        this.cf = cf;\n        this.ngZone = ngZone;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.propagateChange = (_) => {\n        };\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        this.cf.markForCheck();\n    }\n    ngOnInit() {\n        console.log('ngOnInit');\n        if (isPlatformBrowser(this.platformId)) {\n            const options = {\n                // types: ['address'],\n                // componentRestrictions: {country: this.country},\n                placeIdOnly: this.placeIdOnly,\n                strictBounds: this.strictBounds,\n                // types: this.types,\n                type: this.type\n            };\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.componentRestrictions = { country: this.country } : null;\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.types = this.types : null;\n            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n            this.initGoogleMapsAutocomplete();\n            // console.log('this.ngControl.value', this.ngControl?.control?.value)\n            // console.log('this.ngControl.value', this.ngControl.control.setValue('test'))\n            // this.cf.markForCheck();\n        }\n    }\n    onChangeInputValue() {\n        console.log('in change InputTextFilterDirective');\n        const value = this.elemRef.nativeElement?.value;\n        console.log('value --> ', value);\n        this.value = value;\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach(value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    });\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    this.value = place.formatted_address;\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    writeValue(obj) {\n        if (obj) {\n            console.log('obj --> ');\n            this.value = obj;\n            // this.cf.markForCheck();\n        }\n        console.log('write value', this.value);\n    }\n}\nMatGoogleMapsAutocompleteDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, deps: [{ token: PLATFORM_ID }, { token: i0.ElementRef }, { token: i1.MapsAPILoader }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nMatGoogleMapsAutocompleteDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: { address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\", value: \"value\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, host: { listeners: { \"change\": \"onChangeInputValue()\" } }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n            multi: true\n        }\n    ], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matGoogleMapsAutocomplete]',\n                    exportAs: 'matGoogleMapsAutocomplete',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                            multi: true\n                        }\n                    ]\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.ElementRef }, { type: i1.MapsAPILoader }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }]; }, propDecorators: { address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }], onChangeInputValue: [{\n                type: HostListener,\n                args: ['change']\n            }] } });\n\nclass MatSearchGoogleMapsAutocompleteComponent {\n    constructor(formBuilder) {\n        this.formBuilder = formBuilder;\n        this.appearance = Appearance.STANDARD;\n        this.searchAddressLabel = 'Search Address';\n        this.streetNameLabel = 'Street';\n        this.streetNumberLabel = 'Nr.';\n        this.postalCodeLabel = 'PLZ';\n        this.localityLabel = 'Locality';\n        this.vicinityLabel = 'Vicinity';\n        this.onGermanAddressMapped = new EventEmitter();\n        this.firstInit = true;\n        this.propagateChange = (_) => {\n        };\n        // Set the private defaults\n        this._unsubscribeAll = new Subject();\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        console.log('setValue', this._value);\n    }\n    ngOnInit() {\n        this.createAddressFormGroup();\n        this.enableCustomInput();\n    }\n    createAddressFormGroup() {\n        this.addressFormGroup = this.formBuilder.group({\n            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n            locality: this.formBuilder.group({\n                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n            }),\n        });\n    }\n    enableCustomInput() {\n        this.addressFormGroup\n            .get('streetName')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetName => {\n            console.log('custom input for street Name', streetName);\n            console.log('custom input - new german address streetName', this.value);\n            !this.value ? this.value = { streetName } : this.value.streetName = streetName;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('streetNumber')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetNumber => {\n            !this.value ? this.value = { streetNumber } : this.value.streetNumber = streetNumber;\n            console.log('custom input - new german address streetNumber', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('postalCode')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(postalCode => {\n            !this.value ? this.value = { postalCode } : this.value.postalCode = postalCode;\n            console.log('custom input - new german address postalCode', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('vicinity')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(vicinity => {\n            !this.value ? this.value = { vicinity } : this.value.vicinity = vicinity;\n            console.log('custom input - new german address vicinity', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('locality')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(locality => {\n            !this.value ? this.value = { locality } : this.value.locality = locality;\n            console.log('custom input - new german address locality', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n    }\n    parseDisplayAddress() {\n        return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`;\n    }\n    syncAutoComplete($event) {\n        if (this.germanAddress) {\n            this.addressFormGroup.reset();\n        }\n        const germanAddress = parseGermanAddress($event);\n        this.germanAddress = germanAddress;\n        if (germanAddress.vicinity) {\n            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetName) {\n            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetNumber) {\n            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.postalCode) {\n            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.locality && germanAddress.locality.long) {\n            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, { emitEvent: false, onlySelf: true });\n        }\n        this.value = germanAddress;\n        this.onGermanAddressMapped.emit(germanAddress);\n    }\n    writeValue(obj) {\n        let shouldRecreateFG = false;\n        if (obj) {\n            if (!this.value && this.firstInit) {\n                shouldRecreateFG = true;\n            }\n            this.value = obj;\n            if (shouldRecreateFG) {\n                this.createAddressFormGroup();\n                this.firstInit = false;\n            }\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n    }\n}\nMatSearchGoogleMapsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, deps: [{ token: i1$1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });\nMatSearchGoogleMapsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatSearchGoogleMapsAutocompleteComponent, selector: \"mat-search-google-maps-autocomplete\", inputs: { searchBarAppearance: \"searchBarAppearance\", appearance: \"appearance\", searchAddressLabel: \"searchAddressLabel\", streetNameLabel: \"streetNameLabel\", streetNumberLabel: \"streetNumberLabel\", postalCodeLabel: \"postalCodeLabel\", localityLabel: \"localityLabel\", vicinityLabel: \"vicinityLabel\", showVicinity: \"showVicinity\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", readonly: \"readonly\", disableSearch: \"disableSearch\", _value: \"_value\", value: \"value\" }, outputs: { onGermanAddressMapped: \"onGermanAddressMapped\" }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n            multi: true\n        }\n    ], ngImport: i0, template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"], components: [{ type: i2.MatFormField, selector: \"mat-form-field\", inputs: [\"color\", \"appearance\", \"hideRequiredMarker\", \"hintLabel\", \"floatLabel\"], exportAs: [\"matFormField\"] }, { type: i3$1.MatIcon, selector: \"mat-icon\", inputs: [\"color\", \"inline\", \"svgIcon\", \"fontSet\", \"fontIcon\"], exportAs: [\"matIcon\"] }], directives: [{ type: i4.DefaultLayoutDirective, selector: \"  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],  [fxLayout.gt-md], [fxLayout.gt-lg]\", inputs: [\"fxLayout\", \"fxLayout.xs\", \"fxLayout.sm\", \"fxLayout.md\", \"fxLayout.lg\", \"fxLayout.xl\", \"fxLayout.lt-sm\", \"fxLayout.lt-md\", \"fxLayout.lt-lg\", \"fxLayout.lt-xl\", \"fxLayout.gt-xs\", \"fxLayout.gt-sm\", \"fxLayout.gt-md\", \"fxLayout.gt-lg\"] }, { type: i6.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i4.DefaultFlexDirective, selector: \"  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],  [fxFlex.gt-md], [fxFlex.gt-lg]\", inputs: [\"fxFlex\", \"fxFlex.xs\", \"fxFlex.sm\", \"fxFlex.md\", \"fxFlex.lg\", \"fxFlex.xl\", \"fxFlex.lt-sm\", \"fxFlex.lt-md\", \"fxFlex.lt-lg\", \"fxFlex.lt-xl\", \"fxFlex.gt-xs\", \"fxFlex.gt-sm\", \"fxFlex.gt-md\", \"fxFlex.gt-lg\"] }, { type: i2.MatLabel, selector: \"mat-label\" }, { type: i3.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: [\"address\", \"country\", \"placeIdOnly\", \"strictBounds\", \"types\", \"type\", \"autoCompleteOptions\", \"value\"], outputs: [\"onChange\", \"onAutocompleteSelected\", \"onGermanAddressMapped\", \"onLocationSelected\"], exportAs: [\"matGoogleMapsAutocomplete\"] }, { type: i2.MatSuffix, selector: \"[matSuffix]\" }, { type: i1$1.ɵNgNoValidate, selector: \"form:not([ngNoForm]):not([ngNativeValidate])\" }, { type: i1$1.NgControlStatusGroup, selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\" }, { type: i4.DefaultLayoutGapDirective, selector: \"  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\", inputs: [\"fxLayoutGap\", \"fxLayoutGap.xs\", \"fxLayoutGap.sm\", \"fxLayoutGap.md\", \"fxLayoutGap.lg\", \"fxLayoutGap.xl\", \"fxLayoutGap.lt-sm\", \"fxLayoutGap.lt-md\", \"fxLayoutGap.lt-lg\", \"fxLayoutGap.lt-xl\", \"fxLayoutGap.gt-xs\", \"fxLayoutGap.gt-sm\", \"fxLayoutGap.gt-md\", \"fxLayoutGap.gt-lg\"] }, { type: i1$1.FormGroupDirective, selector: \"[formGroup]\", inputs: [\"formGroup\"], outputs: [\"ngSubmit\"], exportAs: [\"ngForm\"] }, { type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { type: i1$1.FormControlName, selector: \"[formControlName]\", inputs: [\"formControlName\", \"disabled\", \"ngModel\"], outputs: [\"ngModelChange\"] }, { type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { type: i1$1.NumberValueAccessor, selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\" }, { type: i1$1.FormGroupName, selector: \"[formGroupName]\", inputs: [\"formGroupName\"] }], animations: InputAnimations });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-search-google-maps-autocomplete', animations: InputAnimations, providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"] }]\n        }], ctorParameters: function () { return [{ type: i1$1.FormBuilder }]; }, propDecorators: { searchBarAppearance: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], searchAddressLabel: [{\n                type: Input\n            }], streetNameLabel: [{\n                type: Input\n            }], streetNumberLabel: [{\n                type: Input\n            }], postalCodeLabel: [{\n                type: Input\n            }], localityLabel: [{\n                type: Input\n            }], vicinityLabel: [{\n                type: Input\n            }], showVicinity: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }], disableSearch: [{\n                type: Input\n            }], _value: [{\n                type: Input\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }] } });\n\nclass MatGoogleMapsAutocompleteModule {\n}\nMatGoogleMapsAutocompleteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatGoogleMapsAutocompleteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, declarations: [MatGoogleMapsAutocompleteComponent,\n        MatGoogleMapsAutocompleteDirective,\n        MatValidateAddressDirective,\n        MatSearchGoogleMapsAutocompleteComponent], imports: [CommonModule,\n        FormsModule,\n        ReactiveFormsModule,\n        FlexLayoutModule,\n        MatInputModule,\n        MatIconModule], exports: [MatGoogleMapsAutocompleteComponent,\n        MatGoogleMapsAutocompleteDirective,\n        MatValidateAddressDirective,\n        MatSearchGoogleMapsAutocompleteComponent] });\nMatGoogleMapsAutocompleteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, imports: [[\n            CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule\n        ]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule,\n                        ReactiveFormsModule,\n                        FlexLayoutModule,\n                        MatInputModule,\n                        MatIconModule\n                    ],\n                    exports: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    declarations: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of google-maps-autocomplete\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatSearchGoogleMapsAutocompleteComponent, MatValidateAddressDirective, parseGermanAddress };\n//# sourceMappingURL=angular-material-extensions-google-maps-autocomplete.mjs.map\n","map":{"version":3,"file":"angular-material-extensions-google-maps-autocomplete.mjs","sources":["../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/helpers/parser.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/address-validator/mat-address-validator.directive.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.html","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/animations/index.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/mat-google-maps-autocomplete.directive.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.html","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/mat-google-maps-autocomplete.module.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/public-api.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/angular-material-extensions-google-maps-autocomplete.ts"],"sourcesContent":["import PlaceResult = google.maps.places.PlaceResult;\nimport {GermanAddress} from '../interfaces';\n\nexport function parseGermanAddress(placeResult: PlaceResult): GermanAddress {\n  const germanAddress: GermanAddress = {\n    gmID: placeResult.id,\n    icon: placeResult.icon,\n    url: placeResult.url,\n    placeID: placeResult.place_id,\n    displayAddress: placeResult.formatted_address,\n    name: placeResult.name,\n    vicinity: placeResult.vicinity,\n    locality: {},\n    state: {},\n    country: {},\n    geoLocation: {latitude: -1, longitude: -1},\n  };\n\n  if (placeResult.geometry && placeResult.geometry.location) {\n    germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n    germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n  }\n\n  if (placeResult.address_components && placeResult.address_components.length > 0) {\n    placeResult.address_components.forEach(value => {\n      if (value.types.indexOf('street_number') > -1) {\n        germanAddress.streetNumber = value.short_name;\n      }\n      if (value.types.indexOf('route') > -1) {\n        germanAddress.streetName = value.long_name;\n      }\n      if (value.types.indexOf('postal_code') > -1) {\n        germanAddress.postalCode = Number(value.short_name);\n      }\n      if (value.types.indexOf('sublocality') > -1) {\n        germanAddress.sublocality = value.long_name;\n      }\n      if (value.types.indexOf('locality') > -1) {\n        germanAddress.locality.long = value.long_name;\n        germanAddress.locality.short = value.short_name;\n      }\n      if (value.types.indexOf('administrative_area_level_1') > -1) {\n        germanAddress.state.long = value.long_name;\n        germanAddress.state.short = value.short_name;\n      }\n      if (value.types.indexOf('country') > -1) {\n        germanAddress.country.long = value.long_name;\n        germanAddress.country.short = value.short_name;\n      }\n      if (value.types.indexOf('administrative_area_level_3') > -1) {\n        germanAddress.locality.short = value.short_name;\n      }\n    });\n  }\n  return germanAddress;\n}\n","import {Directive, EventEmitter, forwardRef} from '@angular/core';\nimport {AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn} from '@angular/forms';\nimport PlaceResult = google.maps.places.PlaceResult;\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\n\n@Directive({\n  selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n  providers: [\n    {provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true}\n  ]\n})\nexport class MatValidateAddressDirective implements Validator {\n\n  public subscription: any;\n\n  private _address: PlaceResult;\n\n\n  constructor() {\n  }\n\n  public validate(): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | any => {\n      return this.address ? null : {\n        validateAddress: {\n          valid: false\n        }\n      };\n    }\n  }\n\n  public subscribe(eventEmitter: EventEmitter<any>) {\n    this.subscription = eventEmitter.subscribe((address: PlaceResult) => {\n      this.address = address;\n    });\n  }\n\n  public unsubscribe() {\n    this.subscription.unsubscribe();\n  }\n\n  get address() {\n    return this._address;\n  }\n\n  set address(value) {\n    this._address = value;\n  }\n}\n","import {Component, ElementRef, EventEmitter, forwardRef, Input, NgZone, OnInit, Output, ViewChild} from '@angular/core';\nimport {ControlValueAccessor, FormControl, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\nimport {MapsAPILoader} from '@agm/core';\nimport {MatValidateAddressDirective} from '../directives/address-validator/mat-address-validator.directive';\nimport {Location} from '../interfaces/location.interface';\nimport {GermanAddress} from '../interfaces';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\n\nexport enum Appearance {\n  STANDARD = 'standard',\n  FILL = 'fill',\n  OUTLINE = 'outline',\n  LEGACY = 'legacy',\n}\n\n@Component({\n  selector: 'mat-google-maps-autocomplete',\n  exportAs: 'matGoogleMapsAutocomplete',\n  templateUrl: './mat-google-maps-autocomplete.component.html',\n  styleUrls: ['./mat-google-maps-autocomplete.component.scss'],\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n      multi: true\n    }\n  ]\n})\nexport class MatGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\n\n  @ViewChild('search')\n  public searchElementRef: ElementRef;\n\n  @Input()\n  addressLabelText = 'Address';\n\n  @Input()\n  placeholderText = 'Please enter the address';\n\n  @Input()\n  requiredErrorText = 'The address is required';\n\n  @Input()\n  invalidErrorText = 'The address is not valid';\n\n  @Input()\n  appearance: string | Appearance = Appearance.STANDARD;\n\n  @Input()\n  value: PlaceResult;\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n  // types: string[] = ['address'];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n  private addressValidator: MatValidateAddressDirective = new MatValidateAddressDirective();\n\n  public addressSearchControl: FormControl = new FormControl({value: null}, Validators.compose([\n    Validators.required,\n    this.addressValidator.validate()])\n  );\n\n  propagateChange = (_: any) => {\n  };\n\n  constructor(private mapsAPILoader: MapsAPILoader,\n              private ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    this.addressValidator.subscribe(this.onNewPlaceResult);\n\n    const options: AutocompleteOptions = {\n      // types: ['address'],\n      // componentRestrictions: {country: this.country},\n      placeIdOnly: this.placeIdOnly,\n      strictBounds: this.strictBounds,\n      // types: this.types,\n      type: this.type\n    };\n\n    // tslint:disable-next-line:no-unused-expression\n    this.country ? options.componentRestrictions = {country: this.country} : null;\n    // tslint:disable-next-line:no-unused-expression\n    this.country ? options.types = this.types : null;\n\n    this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n    this.initGoogleMapsAutocomplete();\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this.mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this.ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            const germanAddress: GermanAddress = {\n              gmID: place.id,\n              icon: place.icon,\n              url: place.url,\n              placeID: place.place_id,\n              displayAddress: place.formatted_address,\n              name: place.name,\n              vicinity: place.vicinity,\n              locality: {},\n              state: {},\n              country: {},\n              geoLocation: {latitude: -1, longitude: -1},\n            };\n\n            if (place.geometry && place.geometry.location) {\n              germanAddress.geoLocation.latitude = place.geometry.location.lat();\n              germanAddress.geoLocation.longitude = place.geometry.location.lng();\n            }\n\n            place.address_components.forEach(value => {\n              if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n              }\n              if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n              }\n              if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n              }\n              if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n              }\n              if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n              }\n              if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n              }\n            });\n\n            this.onGermanAddressMapped.emit(germanAddress);\n\n            if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n              // place result is not valid\n              return;\n            } else {\n              // show dialog to select a address from the input\n              // emit failed event\n              this.value = place;\n              this.propagateChange(this.value)\n            }\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            // console.log('onAutocompleteSelected -> ', place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              });\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n  public onQuery(event: any) {\n    // console.log('onChange()', event);\n    this.onChange.emit(this.address);\n  }\n\n  private resetAddress() {\n    this.address = null;\n    this.addressSearchControl.updateValueAndValidity();\n  }\n\n  writeValue(obj: any): void {\n    if (obj) {\n      this.value = obj;\n    }\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n    throw new Error('Method not implemented.');\n  }\n\n  setDisabledState?(isDisabled: boolean): void {\n    throw new Error('Method not implemented.');\n  }\n\n}\n","<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n","import {animate, animateChild, animation, query, stagger, state, style, transition, trigger, useAnimation} from '@angular/animations';\n\nconst customAnimation = animation(\n  [\n    style({\n      opacity: '{{opacity}}',\n      transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n  ],\n  {\n    params: {\n      duration: '200ms',\n      delay: '0ms',\n      opacity: '0',\n      scale: '1',\n      x: '0',\n      y: '0',\n      z: '0'\n    }\n  }\n);\n\nexport const InputAnimations = [\n  trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n\n  trigger('animateStagger', [\n    state('50', style('*')),\n    state('100', style('*')),\n    state('200', style('*')),\n\n    transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], {optional: true})),\n    transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], {optional: true})),\n    transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], {optional: true}))\n  ]),\n];\n","import {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  HostListener,\n  Inject,\n  Input,\n  NgZone,\n  OnInit,\n  Output,\n  PLATFORM_ID\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {MapsAPILoader} from '@agm/core';\nimport {Location} from '../interfaces/location.interface';\nimport {isPlatformBrowser} from '@angular/common';\nimport {GermanAddress} from '../interfaces/germand.address.interface';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\n\n@Directive({\n  selector: '[matGoogleMapsAutocomplete]',\n  exportAs: 'matGoogleMapsAutocomplete',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n      multi: true\n    }\n  ]\n})\nexport class MatGoogleMapsAutocompleteDirective implements OnInit, ControlValueAccessor {\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n  disabled: boolean\n\n  _value: string;\n\n  get value(): string {\n    return this._value;\n  }\n\n  @Input()\n  set value(value: string) {\n    this._value = value;\n    this.propagateChange(this.value);\n    this.cf.markForCheck();\n  }\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n\n  propagateChange = (_: any) => {\n  };\n\n  constructor(@Inject(PLATFORM_ID) public platformId: string,\n              // @Optional() @Self() public ngControl: NgControl,\n              public elemRef: ElementRef,\n              public mapsAPILoader: MapsAPILoader,\n              private cf: ChangeDetectorRef,\n              private ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    console.log('ngOnInit');\n    if (isPlatformBrowser(this.platformId)) {\n      const options: AutocompleteOptions = {\n        // types: ['address'],\n        // componentRestrictions: {country: this.country},\n        placeIdOnly: this.placeIdOnly,\n        strictBounds: this.strictBounds,\n        // types: this.types,\n        type: this.type\n      };\n\n      // tslint:disable-next-line:no-unused-expression\n      this.country ? options.componentRestrictions = {country: this.country} : null;\n      // tslint:disable-next-line:no-unused-expression\n      this.country ? options.types = this.types : null;\n\n      this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n      this.initGoogleMapsAutocomplete();\n\n      // console.log('this.ngControl.value', this.ngControl?.control?.value)\n      // console.log('this.ngControl.value', this.ngControl.control.setValue('test'))\n      // this.cf.markForCheck();\n    }\n  }\n\n  @HostListener('change')\n  onChangeInputValue(): void {\n    console.log('in change InputTextFilterDirective');\n    const value = (this.elemRef.nativeElement as HTMLInputElement)?.value;\n    console.log('value --> ', value)\n    this.value = value;\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this.mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this.ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            const germanAddress: GermanAddress = {\n              gmID: place.id,\n              icon: place.icon,\n              url: place.url,\n              placeID: place.place_id,\n              displayAddress: place.formatted_address,\n              name: place.name,\n              vicinity: place.vicinity,\n              locality: {},\n              state: {},\n              country: {},\n              geoLocation: {latitude: -1, longitude: -1},\n            };\n\n            if (place.geometry && place.geometry.location) {\n              germanAddress.geoLocation.latitude = place.geometry.location.lat();\n              germanAddress.geoLocation.longitude = place.geometry.location.lng();\n            }\n\n            place.address_components.forEach(value => {\n              if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n              }\n              if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n              }\n              if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n              }\n              if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n              }\n              if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n              }\n              if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n              }\n            });\n\n            this.onGermanAddressMapped.emit(germanAddress);\n\n            this.value = place.formatted_address;\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              });\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  writeValue(obj: any): void {\n    if (obj) {\n      console.log('obj --> ');\n      this.value = obj;\n      // this.cf.markForCheck();\n    }\n    console.log('write value', this.value);\n  }\n\n}\n","import {Component, EventEmitter, forwardRef, Input, OnInit, Output} from '@angular/core';\nimport {ControlValueAccessor, FormBuilder, FormGroup, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\n\nimport {parseGermanAddress} from '../../helpers/parser';\nimport {GermanAddress} from '../../interfaces';\nimport {Appearance} from '../mat-google-maps-autocomplete.component';\nimport {InputAnimations} from '../../animations';\nimport {debounceTime, distinctUntilChanged, takeUntil} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\n\n@Component({\n  selector: 'mat-search-google-maps-autocomplete',\n  templateUrl: './mat-search-google-maps-autocomplete.component.html',\n  styleUrls: ['./mat-search-google-maps-autocomplete.component.scss'],\n  animations: InputAnimations,\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n      multi: true\n    }\n  ]\n})\nexport class MatSearchGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\n\n  constructor(private formBuilder: FormBuilder) {\n    // Set the private defaults\n    this._unsubscribeAll = new Subject();\n  }\n\n  @Input()\n  searchBarAppearance: string | Appearance;\n\n  @Input()\n  appearance: string | Appearance = Appearance.STANDARD;\n\n  @Input()\n  searchAddressLabel = 'Search Address';\n\n  @Input()\n  streetNameLabel = 'Street';\n\n  @Input()\n  streetNumberLabel = 'Nr.';\n\n  @Input()\n  postalCodeLabel = 'PLZ';\n\n  @Input()\n  localityLabel = 'Locality';\n\n  @Input()\n  vicinityLabel = 'Vicinity';\n\n  @Input()\n  showVicinity: boolean;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n  // types: string[] = ['address'];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  readonly: boolean;\n\n  @Input()\n  disableSearch: boolean;\n\n  @Input() private _value: GermanAddress;\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  germanAddress: GermanAddress;\n  addressFormGroup: FormGroup;\n\n  firstInit = true;\n\n  // Private\n  private _unsubscribeAll: Subject<any>;\n\n  propagateChange = (_: any) => {\n  };\n\n\n  get value(): GermanAddress {\n    return this._value;\n  }\n\n  @Input()\n  set value(value: GermanAddress) {\n    this._value = value;\n    this.propagateChange(this.value);\n    console.log('setValue', this._value);\n  }\n\n  ngOnInit() {\n    this.createAddressFormGroup();\n    this.enableCustomInput();\n  }\n\n  createAddressFormGroup(): void {\n    this.addressFormGroup = this.formBuilder.group({\n      streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n      streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n      postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n      vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n      locality: this.formBuilder.group({\n        long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n      }),\n    });\n  }\n\n  enableCustomInput() {\n    this.addressFormGroup\n      .get('streetName')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(streetName => {\n        console.log('custom input for street Name', streetName);\n        console.log('custom input - new german address streetName', this.value);\n        !this.value ? this.value = {streetName} : this.value.streetName = streetName;\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('streetNumber')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(streetNumber => {\n        !this.value ? this.value = {streetNumber} : this.value.streetNumber = streetNumber;\n        console.log('custom input - new german address streetNumber', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('postalCode')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(postalCode => {\n        !this.value ? this.value = {postalCode} : this.value.postalCode = postalCode;\n        console.log('custom input - new german address postalCode', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('vicinity')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(vicinity => {\n        !this.value ? this.value = {vicinity} : this.value.vicinity = vicinity;\n        console.log('custom input - new german address vicinity', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('locality')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(locality => {\n        !this.value ? this.value = {locality} : this.value.locality = locality;\n        console.log('custom input - new german address locality', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n  }\n\n  parseDisplayAddress() {\n    return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`\n  }\n\n  syncAutoComplete($event: google.maps.places.PlaceResult) {\n    if (this.germanAddress) {\n      this.addressFormGroup.reset();\n    }\n    const germanAddress: GermanAddress = parseGermanAddress($event);\n    this.germanAddress = germanAddress;\n    if (germanAddress.vicinity) {\n      this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.streetName) {\n      this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.streetNumber) {\n      this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.postalCode) {\n      this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.locality && germanAddress.locality.long) {\n      this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, {emitEvent: false, onlySelf: true});\n    }\n\n    this.value = germanAddress;\n    this.onGermanAddressMapped.emit(germanAddress);\n  }\n\n  writeValue(obj: any): void {\n    let shouldRecreateFG = false;\n    if (obj) {\n      if (!this.value && this.firstInit) {\n        shouldRecreateFG = true;\n      }\n      this.value = obj;\n      if (shouldRecreateFG) {\n        this.createAddressFormGroup();\n        this.firstInit = false;\n      }\n    }\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n  }\n\n}\n","<div fxLayout=\"column\">\n  <div *ngIf=\"!disableSearch\" fxFlex=\"100\">\n    <!--search address-->\n    <mat-form-field fxFlex=\"auto\" [appearance]=\"searchBarAppearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n      <mat-label>{{searchAddressLabel}}</mat-label>\n      <input\n        (onAutocompleteSelected)=\"syncAutoComplete($event)\"\n        [country]=\"country\"\n        [placeIdOnly]=\"placeIdOnly\"\n        [strictBounds]=\"strictBounds\"\n        [types]=\"types\"\n        [type]=\"type\"\n        matGoogleMapsAutocomplete\n        matInput\n        required\n      />\n      <mat-icon color=\"primary\" matSuffix>search</mat-icon>\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n    </mat-form-field>\n  </div>\n\n  <form [formGroup]=\"addressFormGroup\" fxFlex fxLayoutGap=\"10px\">\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"80\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNameLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetName\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNumberLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetNumber\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n    </div>\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{postalCodeLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"postalCode\"\n          type=\"number\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field *ngIf=\"showVicinity\" fxFlex=\"auto\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{vicinityLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          matInput\n          formControlName=\"vicinity\"\n        />\n      </mat-form-field>\n      <div formGroupName=\"locality\" fxFlex=\"auto\">\n        <mat-form-field fxFlex=\"auto\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n          <mat-label>{{localityLabel}}</mat-label>\n          <input\n            [readonly]=\"readonly\"\n            formControlName=\"long\"\n            matInput\n            required\n          />\n          <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n        </mat-form-field>\n      </div>\n    </div>\n  </form>\n</div>\n","import {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {FlexLayoutModule} from '@angular/flex-layout';\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport {MatGoogleMapsAutocompleteDirective} from './directives/mat-google-maps-autocomplete.directive';\nimport {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\nimport {MatGoogleMapsAutocompleteComponent} from './component/mat-google-maps-autocomplete.component';\n// tslint:disable-next-line:max-line-length\nimport {MatSearchGoogleMapsAutocompleteComponent} from './component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component';\n\n\n@NgModule({\n  imports:\n    [\n      CommonModule,\n      FormsModule,\n      ReactiveFormsModule,\n      FlexLayoutModule,\n      MatInputModule,\n      MatIconModule\n    ],\n  exports: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective,\n    MatSearchGoogleMapsAutocompleteComponent\n  ],\n  declarations: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective,\n    MatSearchGoogleMapsAutocompleteComponent\n  ]\n})\nexport class MatGoogleMapsAutocompleteModule {\n}\n","/*\n * Public API Surface of google-maps-autocomplete\n */\n\nexport * from './lib/helpers/parser';\nexport * from './lib/interfaces';\nexport * from './lib/component';\nexport * from './lib/directives/mat-google-maps-autocomplete.directive';\nexport * from './lib/directives/address-validator/mat-address-validator.directive';\nexport * from './lib/mat-google-maps-autocomplete.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { forwardRef, Directive, EventEmitter, Component, ViewChild, Input, Output, PLATFORM_ID, Inject, HostListener, NgModule } from '@angular/core';\nimport * as i1$1 from '@angular/forms';\nimport { NG_VALIDATORS, FormControl, Validators, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport * as i1 from '@agm/core';\nimport * as i2 from '@angular/material/form-field';\nimport * as i3 from '@angular/material/input';\nimport { MatInputModule } from '@angular/material/input';\nimport * as i6 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { animation, style, animate, trigger, transition, useAnimation, state, query, stagger, animateChild } from '@angular/animations';\nimport { distinctUntilChanged, debounceTime, takeUntil } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport * as i3$1 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i4 from '@angular/flex-layout/flex';\nimport { FlexLayoutModule } from '@angular/flex-layout';\n\nfunction parseGermanAddress(placeResult) {\n    const germanAddress = {\n        gmID: placeResult.id,\n        icon: placeResult.icon,\n        url: placeResult.url,\n        placeID: placeResult.place_id,\n        displayAddress: placeResult.formatted_address,\n        name: placeResult.name,\n        vicinity: placeResult.vicinity,\n        locality: {},\n        state: {},\n        country: {},\n        geoLocation: { latitude: -1, longitude: -1 },\n    };\n    if (placeResult.geometry && placeResult.geometry.location) {\n        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n    }\n    if (placeResult.address_components && placeResult.address_components.length > 0) {\n        placeResult.address_components.forEach(value => {\n            if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n            }\n            if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n            }\n            if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n            }\n            if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n            }\n            if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n            }\n            if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n            }\n        });\n    }\n    return germanAddress;\n}\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\nclass MatValidateAddressDirective {\n    constructor() {\n    }\n    validate() {\n        return (control) => {\n            return this.address ? null : {\n                validateAddress: {\n                    valid: false\n                }\n            };\n        };\n    }\n    subscribe(eventEmitter) {\n        this.subscription = eventEmitter.subscribe((address) => {\n            this.address = address;\n        });\n    }\n    unsubscribe() {\n        this.subscription.unsubscribe();\n    }\n    get address() {\n        return this._address;\n    }\n    set address(value) {\n        this._address = value;\n    }\n}\nMatValidateAddressDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatValidateAddressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nMatValidateAddressDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\", providers: [\n        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n    ], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatValidateAddressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n                    providers: [\n                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });\n\nvar Appearance;\n(function (Appearance) {\n    Appearance[\"STANDARD\"] = \"standard\";\n    Appearance[\"FILL\"] = \"fill\";\n    Appearance[\"OUTLINE\"] = \"outline\";\n    Appearance[\"LEGACY\"] = \"legacy\";\n})(Appearance || (Appearance = {}));\nclass MatGoogleMapsAutocompleteComponent {\n    constructor(mapsAPILoader, ngZone) {\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n        this.addressLabelText = 'Address';\n        this.placeholderText = 'Please enter the address';\n        this.requiredErrorText = 'The address is required';\n        this.invalidErrorText = 'The address is not valid';\n        this.appearance = Appearance.STANDARD;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.addressValidator = new MatValidateAddressDirective();\n        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([\n            Validators.required,\n            this.addressValidator.validate()\n        ]));\n        this.propagateChange = (_) => {\n        };\n    }\n    ngOnInit() {\n        this.addressValidator.subscribe(this.onNewPlaceResult);\n        const options = {\n            // types: ['address'],\n            // componentRestrictions: {country: this.country},\n            placeIdOnly: this.placeIdOnly,\n            strictBounds: this.strictBounds,\n            // types: this.types,\n            type: this.type\n        };\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.componentRestrictions = { country: this.country } : null;\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.types = this.types : null;\n        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n        this.initGoogleMapsAutocomplete();\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach(value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    });\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                        this.value = place;\n                        this.propagateChange(this.value);\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    // console.log('onAutocompleteSelected -> ', place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    onQuery(event) {\n        // console.log('onChange()', event);\n        this.onChange.emit(this.address);\n    }\n    resetAddress() {\n        this.address = null;\n        this.addressSearchControl.updateValueAndValidity();\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n        throw new Error('Method not implemented.');\n    }\n    setDisabledState(isDisabled) {\n        throw new Error('Method not implemented.');\n    }\n}\nMatGoogleMapsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i1.MapsAPILoader }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\nMatGoogleMapsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatGoogleMapsAutocompleteComponent, selector: \"mat-google-maps-autocomplete\", inputs: { addressLabelText: \"addressLabelText\", placeholderText: \"placeholderText\", requiredErrorText: \"requiredErrorText\", invalidErrorText: \"invalidErrorText\", appearance: \"appearance\", value: \"value\", address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n            multi: true\n        }\n    ], viewQueries: [{ propertyName: \"searchElementRef\", first: true, predicate: [\"search\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0, template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"], components: [{ type: i2.MatFormField, selector: \"mat-form-field\", inputs: [\"color\", \"appearance\", \"hideRequiredMarker\", \"hintLabel\", \"floatLabel\"], exportAs: [\"matFormField\"] }], directives: [{ type: i2.MatLabel, selector: \"mat-label\" }, { type: i3.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\" }, { type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { type: i1$1.NgModel, selector: \"[ngModel]:not([formControlName]):not([formControl])\", inputs: [\"name\", \"disabled\", \"ngModel\", \"ngModelOptions\"], outputs: [\"ngModelChange\"], exportAs: [\"ngModel\"] }, { type: i6.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i2.MatError, selector: \"mat-error\", inputs: [\"id\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: i1.MapsAPILoader }, { type: i0.NgZone }]; }, propDecorators: { searchElementRef: [{\n                type: ViewChild,\n                args: ['search']\n            }], addressLabelText: [{\n                type: Input\n            }], placeholderText: [{\n                type: Input\n            }], requiredErrorText: [{\n                type: Input\n            }], invalidErrorText: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }] } });\n\nconst customAnimation = animation([\n    style({\n        opacity: '{{opacity}}',\n        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n], {\n    params: {\n        duration: '200ms',\n        delay: '0ms',\n        opacity: '0',\n        scale: '1',\n        x: '0',\n        y: '0',\n        z: '0'\n    }\n});\nconst InputAnimations = [\n    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n    trigger('animateStagger', [\n        state('50', style('*')),\n        state('100', style('*')),\n        state('200', style('*')),\n        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),\n        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),\n        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))\n    ]),\n];\n\nclass MatGoogleMapsAutocompleteDirective {\n    constructor(platformId, \n    // @Optional() @Self() public ngControl: NgControl,\n    elemRef, mapsAPILoader, cf, ngZone) {\n        this.platformId = platformId;\n        this.elemRef = elemRef;\n        this.mapsAPILoader = mapsAPILoader;\n        this.cf = cf;\n        this.ngZone = ngZone;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.propagateChange = (_) => {\n        };\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        this.cf.markForCheck();\n    }\n    ngOnInit() {\n        console.log('ngOnInit');\n        if (isPlatformBrowser(this.platformId)) {\n            const options = {\n                // types: ['address'],\n                // componentRestrictions: {country: this.country},\n                placeIdOnly: this.placeIdOnly,\n                strictBounds: this.strictBounds,\n                // types: this.types,\n                type: this.type\n            };\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.componentRestrictions = { country: this.country } : null;\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.types = this.types : null;\n            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n            this.initGoogleMapsAutocomplete();\n            // console.log('this.ngControl.value', this.ngControl?.control?.value)\n            // console.log('this.ngControl.value', this.ngControl.control.setValue('test'))\n            // this.cf.markForCheck();\n        }\n    }\n    onChangeInputValue() {\n        var _a;\n        console.log('in change InputTextFilterDirective');\n        const value = (_a = this.elemRef.nativeElement) === null || _a === void 0 ? void 0 : _a.value;\n        console.log('value --> ', value);\n        this.value = value;\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach(value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    });\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    this.value = place.formatted_address;\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    writeValue(obj) {\n        if (obj) {\n            console.log('obj --> ');\n            this.value = obj;\n            // this.cf.markForCheck();\n        }\n        console.log('write value', this.value);\n    }\n}\nMatGoogleMapsAutocompleteDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, deps: [{ token: PLATFORM_ID }, { token: i0.ElementRef }, { token: i1.MapsAPILoader }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nMatGoogleMapsAutocompleteDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: { address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\", value: \"value\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, host: { listeners: { \"change\": \"onChangeInputValue()\" } }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n            multi: true\n        }\n    ], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matGoogleMapsAutocomplete]',\n                    exportAs: 'matGoogleMapsAutocomplete',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                            multi: true\n                        }\n                    ]\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }, { type: i0.ElementRef }, { type: i1.MapsAPILoader }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }];\n    }, propDecorators: { address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }], onChangeInputValue: [{\n                type: HostListener,\n                args: ['change']\n            }] } });\n\nclass MatSearchGoogleMapsAutocompleteComponent {\n    constructor(formBuilder) {\n        this.formBuilder = formBuilder;\n        this.appearance = Appearance.STANDARD;\n        this.searchAddressLabel = 'Search Address';\n        this.streetNameLabel = 'Street';\n        this.streetNumberLabel = 'Nr.';\n        this.postalCodeLabel = 'PLZ';\n        this.localityLabel = 'Locality';\n        this.vicinityLabel = 'Vicinity';\n        this.onGermanAddressMapped = new EventEmitter();\n        this.firstInit = true;\n        this.propagateChange = (_) => {\n        };\n        // Set the private defaults\n        this._unsubscribeAll = new Subject();\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        console.log('setValue', this._value);\n    }\n    ngOnInit() {\n        this.createAddressFormGroup();\n        this.enableCustomInput();\n    }\n    createAddressFormGroup() {\n        this.addressFormGroup = this.formBuilder.group({\n            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n            locality: this.formBuilder.group({\n                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n            }),\n        });\n    }\n    enableCustomInput() {\n        this.addressFormGroup\n            .get('streetName')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetName => {\n            console.log('custom input for street Name', streetName);\n            console.log('custom input - new german address streetName', this.value);\n            !this.value ? this.value = { streetName } : this.value.streetName = streetName;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('streetNumber')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetNumber => {\n            !this.value ? this.value = { streetNumber } : this.value.streetNumber = streetNumber;\n            console.log('custom input - new german address streetNumber', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('postalCode')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(postalCode => {\n            !this.value ? this.value = { postalCode } : this.value.postalCode = postalCode;\n            console.log('custom input - new german address postalCode', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('vicinity')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(vicinity => {\n            !this.value ? this.value = { vicinity } : this.value.vicinity = vicinity;\n            console.log('custom input - new german address vicinity', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('locality')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(locality => {\n            !this.value ? this.value = { locality } : this.value.locality = locality;\n            console.log('custom input - new german address locality', this.value);\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n    }\n    parseDisplayAddress() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return `${((_a = this.value) === null || _a === void 0 ? void 0 : _a.streetName) ? (_b = this.value) === null || _b === void 0 ? void 0 : _b.streetName : ''} ${((_c = this.value) === null || _c === void 0 ? void 0 : _c.streetNumber) ? (_d = this.value) === null || _d === void 0 ? void 0 : _d.streetNumber : ''}${((_e = this.value) === null || _e === void 0 ? void 0 : _e.postalCode) || ((_g = (_f = this.value) === null || _f === void 0 ? void 0 : _f.locality) === null || _g === void 0 ? void 0 : _g.long) ? ', ' : ''}${((_h = this.value) === null || _h === void 0 ? void 0 : _h.postalCode) ? (_j = this.value) === null || _j === void 0 ? void 0 : _j.postalCode : ''} ${((_l = (_k = this.value) === null || _k === void 0 ? void 0 : _k.locality) === null || _l === void 0 ? void 0 : _l.long) ? (_o = (_m = this.value) === null || _m === void 0 ? void 0 : _m.locality) === null || _o === void 0 ? void 0 : _o.long : ''}`;\n    }\n    syncAutoComplete($event) {\n        if (this.germanAddress) {\n            this.addressFormGroup.reset();\n        }\n        const germanAddress = parseGermanAddress($event);\n        this.germanAddress = germanAddress;\n        if (germanAddress.vicinity) {\n            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetName) {\n            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetNumber) {\n            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.postalCode) {\n            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.locality && germanAddress.locality.long) {\n            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, { emitEvent: false, onlySelf: true });\n        }\n        this.value = germanAddress;\n        this.onGermanAddressMapped.emit(germanAddress);\n    }\n    writeValue(obj) {\n        let shouldRecreateFG = false;\n        if (obj) {\n            if (!this.value && this.firstInit) {\n                shouldRecreateFG = true;\n            }\n            this.value = obj;\n            if (shouldRecreateFG) {\n                this.createAddressFormGroup();\n                this.firstInit = false;\n            }\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n    }\n}\nMatSearchGoogleMapsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, deps: [{ token: i1$1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });\nMatSearchGoogleMapsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.2\", type: MatSearchGoogleMapsAutocompleteComponent, selector: \"mat-search-google-maps-autocomplete\", inputs: { searchBarAppearance: \"searchBarAppearance\", appearance: \"appearance\", searchAddressLabel: \"searchAddressLabel\", streetNameLabel: \"streetNameLabel\", streetNumberLabel: \"streetNumberLabel\", postalCodeLabel: \"postalCodeLabel\", localityLabel: \"localityLabel\", vicinityLabel: \"vicinityLabel\", showVicinity: \"showVicinity\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", readonly: \"readonly\", disableSearch: \"disableSearch\", _value: \"_value\", value: \"value\" }, outputs: { onGermanAddressMapped: \"onGermanAddressMapped\" }, providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n            multi: true\n        }\n    ], ngImport: i0, template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"], components: [{ type: i2.MatFormField, selector: \"mat-form-field\", inputs: [\"color\", \"appearance\", \"hideRequiredMarker\", \"hintLabel\", \"floatLabel\"], exportAs: [\"matFormField\"] }, { type: i3$1.MatIcon, selector: \"mat-icon\", inputs: [\"color\", \"inline\", \"svgIcon\", \"fontSet\", \"fontIcon\"], exportAs: [\"matIcon\"] }], directives: [{ type: i4.DefaultLayoutDirective, selector: \"  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],  [fxLayout.gt-md], [fxLayout.gt-lg]\", inputs: [\"fxLayout\", \"fxLayout.xs\", \"fxLayout.sm\", \"fxLayout.md\", \"fxLayout.lg\", \"fxLayout.xl\", \"fxLayout.lt-sm\", \"fxLayout.lt-md\", \"fxLayout.lt-lg\", \"fxLayout.lt-xl\", \"fxLayout.gt-xs\", \"fxLayout.gt-sm\", \"fxLayout.gt-md\", \"fxLayout.gt-lg\"] }, { type: i6.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i4.DefaultFlexDirective, selector: \"  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],  [fxFlex.gt-md], [fxFlex.gt-lg]\", inputs: [\"fxFlex\", \"fxFlex.xs\", \"fxFlex.sm\", \"fxFlex.md\", \"fxFlex.lg\", \"fxFlex.xl\", \"fxFlex.lt-sm\", \"fxFlex.lt-md\", \"fxFlex.lt-lg\", \"fxFlex.lt-xl\", \"fxFlex.gt-xs\", \"fxFlex.gt-sm\", \"fxFlex.gt-md\", \"fxFlex.gt-lg\"] }, { type: i2.MatLabel, selector: \"mat-label\" }, { type: i3.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: [\"address\", \"country\", \"placeIdOnly\", \"strictBounds\", \"types\", \"type\", \"autoCompleteOptions\", \"value\"], outputs: [\"onChange\", \"onAutocompleteSelected\", \"onGermanAddressMapped\", \"onLocationSelected\"], exportAs: [\"matGoogleMapsAutocomplete\"] }, { type: i2.MatSuffix, selector: \"[matSuffix]\" }, { type: i1$1.ɵNgNoValidate, selector: \"form:not([ngNoForm]):not([ngNativeValidate])\" }, { type: i1$1.NgControlStatusGroup, selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\" }, { type: i4.DefaultLayoutGapDirective, selector: \"  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\", inputs: [\"fxLayoutGap\", \"fxLayoutGap.xs\", \"fxLayoutGap.sm\", \"fxLayoutGap.md\", \"fxLayoutGap.lg\", \"fxLayoutGap.xl\", \"fxLayoutGap.lt-sm\", \"fxLayoutGap.lt-md\", \"fxLayoutGap.lt-lg\", \"fxLayoutGap.lt-xl\", \"fxLayoutGap.gt-xs\", \"fxLayoutGap.gt-sm\", \"fxLayoutGap.gt-md\", \"fxLayoutGap.gt-lg\"] }, { type: i1$1.FormGroupDirective, selector: \"[formGroup]\", inputs: [\"formGroup\"], outputs: [\"ngSubmit\"], exportAs: [\"ngForm\"] }, { type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { type: i1$1.FormControlName, selector: \"[formControlName]\", inputs: [\"formControlName\", \"disabled\", \"ngModel\"], outputs: [\"ngModelChange\"] }, { type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { type: i1$1.NumberValueAccessor, selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\" }, { type: i1$1.FormGroupName, selector: \"[formGroupName]\", inputs: [\"formGroupName\"] }], animations: InputAnimations });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-search-google-maps-autocomplete', animations: InputAnimations, providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"] }]\n        }], ctorParameters: function () { return [{ type: i1$1.FormBuilder }]; }, propDecorators: { searchBarAppearance: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], searchAddressLabel: [{\n                type: Input\n            }], streetNameLabel: [{\n                type: Input\n            }], streetNumberLabel: [{\n                type: Input\n            }], postalCodeLabel: [{\n                type: Input\n            }], localityLabel: [{\n                type: Input\n            }], vicinityLabel: [{\n                type: Input\n            }], showVicinity: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }], disableSearch: [{\n                type: Input\n            }], _value: [{\n                type: Input\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }] } });\n\nclass MatGoogleMapsAutocompleteModule {\n}\nMatGoogleMapsAutocompleteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatGoogleMapsAutocompleteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, declarations: [MatGoogleMapsAutocompleteComponent,\n        MatGoogleMapsAutocompleteDirective,\n        MatValidateAddressDirective,\n        MatSearchGoogleMapsAutocompleteComponent], imports: [CommonModule,\n        FormsModule,\n        ReactiveFormsModule,\n        FlexLayoutModule,\n        MatInputModule,\n        MatIconModule], exports: [MatGoogleMapsAutocompleteComponent,\n        MatGoogleMapsAutocompleteDirective,\n        MatValidateAddressDirective,\n        MatSearchGoogleMapsAutocompleteComponent] });\nMatGoogleMapsAutocompleteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, imports: [[\n            CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule\n        ]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule,\n                        ReactiveFormsModule,\n                        FlexLayoutModule,\n                        MatInputModule,\n                        MatIconModule\n                    ],\n                    exports: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    declarations: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of google-maps-autocomplete\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatSearchGoogleMapsAutocompleteComponent, MatValidateAddressDirective, parseGermanAddress };\n//# sourceMappingURL=angular-material-extensions-google-maps-autocomplete.mjs.map\n","map":{"version":3,"file":"angular-material-extensions-google-maps-autocomplete.mjs","sources":["../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/helpers/parser.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/address-validator/mat-address-validator.directive.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.html","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/animations/index.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/mat-google-maps-autocomplete.directive.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.html","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/mat-google-maps-autocomplete.module.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/public-api.ts","../../../../projects/angular-material-extensions/google-maps-autocomplete/src/angular-material-extensions-google-maps-autocomplete.ts"],"sourcesContent":["import PlaceResult = google.maps.places.PlaceResult;\nimport {GermanAddress} from '../interfaces';\n\nexport function parseGermanAddress(placeResult: PlaceResult): GermanAddress {\n  const germanAddress: GermanAddress = {\n    gmID: placeResult.id,\n    icon: placeResult.icon,\n    url: placeResult.url,\n    placeID: placeResult.place_id,\n    displayAddress: placeResult.formatted_address,\n    name: placeResult.name,\n    vicinity: placeResult.vicinity,\n    locality: {},\n    state: {},\n    country: {},\n    geoLocation: {latitude: -1, longitude: -1},\n  };\n\n  if (placeResult.geometry && placeResult.geometry.location) {\n    germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n    germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n  }\n\n  if (placeResult.address_components && placeResult.address_components.length > 0) {\n    placeResult.address_components.forEach(value => {\n      if (value.types.indexOf('street_number') > -1) {\n        germanAddress.streetNumber = value.short_name;\n      }\n      if (value.types.indexOf('route') > -1) {\n        germanAddress.streetName = value.long_name;\n      }\n      if (value.types.indexOf('postal_code') > -1) {\n        germanAddress.postalCode = Number(value.short_name);\n      }\n      if (value.types.indexOf('sublocality') > -1) {\n        germanAddress.sublocality = value.long_name;\n      }\n      if (value.types.indexOf('locality') > -1) {\n        germanAddress.locality.long = value.long_name;\n        germanAddress.locality.short = value.short_name;\n      }\n      if (value.types.indexOf('administrative_area_level_1') > -1) {\n        germanAddress.state.long = value.long_name;\n        germanAddress.state.short = value.short_name;\n      }\n      if (value.types.indexOf('country') > -1) {\n        germanAddress.country.long = value.long_name;\n        germanAddress.country.short = value.short_name;\n      }\n      if (value.types.indexOf('administrative_area_level_3') > -1) {\n        germanAddress.locality.short = value.short_name;\n      }\n    });\n  }\n  return germanAddress;\n}\n","import {Directive, EventEmitter, forwardRef} from '@angular/core';\nimport {AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn} from '@angular/forms';\nimport PlaceResult = google.maps.places.PlaceResult;\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\n\n@Directive({\n  selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n  providers: [\n    {provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true}\n  ]\n})\nexport class MatValidateAddressDirective implements Validator {\n\n  public subscription: any;\n\n  private _address: PlaceResult;\n\n\n  constructor() {\n  }\n\n  public validate(): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | any => {\n      return this.address ? null : {\n        validateAddress: {\n          valid: false\n        }\n      };\n    }\n  }\n\n  public subscribe(eventEmitter: EventEmitter<any>) {\n    this.subscription = eventEmitter.subscribe((address: PlaceResult) => {\n      this.address = address;\n    });\n  }\n\n  public unsubscribe() {\n    this.subscription.unsubscribe();\n  }\n\n  get address() {\n    return this._address;\n  }\n\n  set address(value) {\n    this._address = value;\n  }\n}\n","import {Component, ElementRef, EventEmitter, forwardRef, Input, NgZone, OnInit, Output, ViewChild} from '@angular/core';\nimport {ControlValueAccessor, FormControl, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\nimport {MapsAPILoader} from '@agm/core';\nimport {MatValidateAddressDirective} from '../directives/address-validator/mat-address-validator.directive';\nimport {Location} from '../interfaces/location.interface';\nimport {GermanAddress} from '../interfaces';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\n\nexport enum Appearance {\n  STANDARD = 'standard',\n  FILL = 'fill',\n  OUTLINE = 'outline',\n  LEGACY = 'legacy',\n}\n\n@Component({\n  selector: 'mat-google-maps-autocomplete',\n  exportAs: 'matGoogleMapsAutocomplete',\n  templateUrl: './mat-google-maps-autocomplete.component.html',\n  styleUrls: ['./mat-google-maps-autocomplete.component.scss'],\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n      multi: true\n    }\n  ]\n})\nexport class MatGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\n\n  @ViewChild('search')\n  public searchElementRef: ElementRef;\n\n  @Input()\n  addressLabelText = 'Address';\n\n  @Input()\n  placeholderText = 'Please enter the address';\n\n  @Input()\n  requiredErrorText = 'The address is required';\n\n  @Input()\n  invalidErrorText = 'The address is not valid';\n\n  @Input()\n  appearance: string | Appearance = Appearance.STANDARD;\n\n  @Input()\n  value: PlaceResult;\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n  // types: string[] = ['address'];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n  private addressValidator: MatValidateAddressDirective = new MatValidateAddressDirective();\n\n  public addressSearchControl: FormControl = new FormControl({value: null}, Validators.compose([\n    Validators.required,\n    this.addressValidator.validate()])\n  );\n\n  propagateChange = (_: any) => {\n  };\n\n  constructor(private mapsAPILoader: MapsAPILoader,\n              private ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    this.addressValidator.subscribe(this.onNewPlaceResult);\n\n    const options: AutocompleteOptions = {\n      // types: ['address'],\n      // componentRestrictions: {country: this.country},\n      placeIdOnly: this.placeIdOnly,\n      strictBounds: this.strictBounds,\n      // types: this.types,\n      type: this.type\n    };\n\n    // tslint:disable-next-line:no-unused-expression\n    this.country ? options.componentRestrictions = {country: this.country} : null;\n    // tslint:disable-next-line:no-unused-expression\n    this.country ? options.types = this.types : null;\n\n    this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n    this.initGoogleMapsAutocomplete();\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this.mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this.ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            const germanAddress: GermanAddress = {\n              gmID: place.id,\n              icon: place.icon,\n              url: place.url,\n              placeID: place.place_id,\n              displayAddress: place.formatted_address,\n              name: place.name,\n              vicinity: place.vicinity,\n              locality: {},\n              state: {},\n              country: {},\n              geoLocation: {latitude: -1, longitude: -1},\n            };\n\n            if (place.geometry && place.geometry.location) {\n              germanAddress.geoLocation.latitude = place.geometry.location.lat();\n              germanAddress.geoLocation.longitude = place.geometry.location.lng();\n            }\n\n            place.address_components.forEach(value => {\n              if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n              }\n              if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n              }\n              if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n              }\n              if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n              }\n              if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n              }\n              if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n              }\n            });\n\n            this.onGermanAddressMapped.emit(germanAddress);\n\n            if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n              // place result is not valid\n              return;\n            } else {\n              // show dialog to select a address from the input\n              // emit failed event\n              this.value = place;\n              this.propagateChange(this.value)\n            }\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            // console.log('onAutocompleteSelected -> ', place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              });\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n  public onQuery(event: any) {\n    // console.log('onChange()', event);\n    this.onChange.emit(this.address);\n  }\n\n  private resetAddress() {\n    this.address = null;\n    this.addressSearchControl.updateValueAndValidity();\n  }\n\n  writeValue(obj: any): void {\n    if (obj) {\n      this.value = obj;\n    }\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n    throw new Error('Method not implemented.');\n  }\n\n  setDisabledState?(isDisabled: boolean): void {\n    throw new Error('Method not implemented.');\n  }\n\n}\n","<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n","import {animate, animateChild, animation, query, stagger, state, style, transition, trigger, useAnimation} from '@angular/animations';\n\nconst customAnimation = animation(\n  [\n    style({\n      opacity: '{{opacity}}',\n      transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n  ],\n  {\n    params: {\n      duration: '200ms',\n      delay: '0ms',\n      opacity: '0',\n      scale: '1',\n      x: '0',\n      y: '0',\n      z: '0'\n    }\n  }\n);\n\nexport const InputAnimations = [\n  trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n\n  trigger('animateStagger', [\n    state('50', style('*')),\n    state('100', style('*')),\n    state('200', style('*')),\n\n    transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], {optional: true})),\n    transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], {optional: true})),\n    transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], {optional: true}))\n  ]),\n];\n","import {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  HostListener,\n  Inject,\n  Input,\n  NgZone,\n  OnInit,\n  Output,\n  PLATFORM_ID\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {MapsAPILoader} from '@agm/core';\nimport {Location} from '../interfaces/location.interface';\nimport {isPlatformBrowser} from '@angular/common';\nimport {GermanAddress} from '../interfaces/germand.address.interface';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\n\n@Directive({\n  selector: '[matGoogleMapsAutocomplete]',\n  exportAs: 'matGoogleMapsAutocomplete',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n      multi: true\n    }\n  ]\n})\nexport class MatGoogleMapsAutocompleteDirective implements OnInit, ControlValueAccessor {\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n  disabled: boolean\n\n  _value: string;\n\n  get value(): string {\n    return this._value;\n  }\n\n  @Input()\n  set value(value: string) {\n    this._value = value;\n    this.propagateChange(this.value);\n    this.cf.markForCheck();\n  }\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n\n  propagateChange = (_: any) => {\n  };\n\n  constructor(@Inject(PLATFORM_ID) public platformId: string,\n              // @Optional() @Self() public ngControl: NgControl,\n              public elemRef: ElementRef,\n              public mapsAPILoader: MapsAPILoader,\n              private cf: ChangeDetectorRef,\n              private ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    console.log('ngOnInit');\n    if (isPlatformBrowser(this.platformId)) {\n      const options: AutocompleteOptions = {\n        // types: ['address'],\n        // componentRestrictions: {country: this.country},\n        placeIdOnly: this.placeIdOnly,\n        strictBounds: this.strictBounds,\n        // types: this.types,\n        type: this.type\n      };\n\n      // tslint:disable-next-line:no-unused-expression\n      this.country ? options.componentRestrictions = {country: this.country} : null;\n      // tslint:disable-next-line:no-unused-expression\n      this.country ? options.types = this.types : null;\n\n      this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n      this.initGoogleMapsAutocomplete();\n\n      // console.log('this.ngControl.value', this.ngControl?.control?.value)\n      // console.log('this.ngControl.value', this.ngControl.control.setValue('test'))\n      // this.cf.markForCheck();\n    }\n  }\n\n  @HostListener('change')\n  onChangeInputValue(): void {\n    console.log('in change InputTextFilterDirective');\n    const value = (this.elemRef.nativeElement as HTMLInputElement)?.value;\n    console.log('value --> ', value)\n    this.value = value;\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this.mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this.ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            const germanAddress: GermanAddress = {\n              gmID: place.id,\n              icon: place.icon,\n              url: place.url,\n              placeID: place.place_id,\n              displayAddress: place.formatted_address,\n              name: place.name,\n              vicinity: place.vicinity,\n              locality: {},\n              state: {},\n              country: {},\n              geoLocation: {latitude: -1, longitude: -1},\n            };\n\n            if (place.geometry && place.geometry.location) {\n              germanAddress.geoLocation.latitude = place.geometry.location.lat();\n              germanAddress.geoLocation.longitude = place.geometry.location.lng();\n            }\n\n            place.address_components.forEach(value => {\n              if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n              }\n              if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n              }\n              if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n              }\n              if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n              }\n              if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n              }\n              if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n              }\n              if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n              }\n            });\n\n            this.onGermanAddressMapped.emit(germanAddress);\n\n            this.value = place.formatted_address;\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              });\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  writeValue(obj: any): void {\n    if (obj) {\n      console.log('obj --> ');\n      this.value = obj;\n      // this.cf.markForCheck();\n    }\n    console.log('write value', this.value);\n  }\n\n}\n","import {Component, EventEmitter, forwardRef, Input, OnInit, Output} from '@angular/core';\nimport {ControlValueAccessor, FormBuilder, FormGroup, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\n\nimport {parseGermanAddress} from '../../helpers/parser';\nimport {GermanAddress} from '../../interfaces';\nimport {Appearance} from '../mat-google-maps-autocomplete.component';\nimport {InputAnimations} from '../../animations';\nimport {debounceTime, distinctUntilChanged, takeUntil} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\n\n@Component({\n  selector: 'mat-search-google-maps-autocomplete',\n  templateUrl: './mat-search-google-maps-autocomplete.component.html',\n  styleUrls: ['./mat-search-google-maps-autocomplete.component.scss'],\n  animations: InputAnimations,\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n      multi: true\n    }\n  ]\n})\nexport class MatSearchGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\n\n  constructor(private formBuilder: FormBuilder) {\n    // Set the private defaults\n    this._unsubscribeAll = new Subject();\n  }\n\n  @Input()\n  searchBarAppearance: string | Appearance;\n\n  @Input()\n  appearance: string | Appearance = Appearance.STANDARD;\n\n  @Input()\n  searchAddressLabel = 'Search Address';\n\n  @Input()\n  streetNameLabel = 'Street';\n\n  @Input()\n  streetNumberLabel = 'Nr.';\n\n  @Input()\n  postalCodeLabel = 'PLZ';\n\n  @Input()\n  localityLabel = 'Locality';\n\n  @Input()\n  vicinityLabel = 'Vicinity';\n\n  @Input()\n  showVicinity: boolean;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n  // types: string[] = ['address'];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  readonly: boolean;\n\n  @Input()\n  disableSearch: boolean;\n\n  @Input() private _value: GermanAddress;\n\n  @Output()\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\n\n  germanAddress: GermanAddress;\n  addressFormGroup: FormGroup;\n\n  firstInit = true;\n\n  // Private\n  private _unsubscribeAll: Subject<any>;\n\n  propagateChange = (_: any) => {\n  };\n\n\n  get value(): GermanAddress {\n    return this._value;\n  }\n\n  @Input()\n  set value(value: GermanAddress) {\n    this._value = value;\n    this.propagateChange(this.value);\n    console.log('setValue', this._value);\n  }\n\n  ngOnInit() {\n    this.createAddressFormGroup();\n    this.enableCustomInput();\n  }\n\n  createAddressFormGroup(): void {\n    this.addressFormGroup = this.formBuilder.group({\n      streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n      streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n      postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n      vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n      locality: this.formBuilder.group({\n        long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n      }),\n    });\n  }\n\n  enableCustomInput() {\n    this.addressFormGroup\n      .get('streetName')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(streetName => {\n        console.log('custom input for street Name', streetName);\n        console.log('custom input - new german address streetName', this.value);\n        !this.value ? this.value = {streetName} : this.value.streetName = streetName;\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('streetNumber')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(streetNumber => {\n        !this.value ? this.value = {streetNumber} : this.value.streetNumber = streetNumber;\n        console.log('custom input - new german address streetNumber', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('postalCode')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(postalCode => {\n        !this.value ? this.value = {postalCode} : this.value.postalCode = postalCode;\n        console.log('custom input - new german address postalCode', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('vicinity')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(vicinity => {\n        !this.value ? this.value = {vicinity} : this.value.vicinity = vicinity;\n        console.log('custom input - new german address vicinity', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n    this.addressFormGroup\n      .get('locality')\n      .valueChanges\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n      .subscribe(locality => {\n        !this.value ? this.value = {locality} : this.value.locality = locality;\n        console.log('custom input - new german address locality', this.value);\n        this.value.displayAddress = this.parseDisplayAddress();\n        this.propagateChange(this.value);\n      });\n  }\n\n  parseDisplayAddress() {\n    return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`\n  }\n\n  syncAutoComplete($event: google.maps.places.PlaceResult) {\n    if (this.germanAddress) {\n      this.addressFormGroup.reset();\n    }\n    const germanAddress: GermanAddress = parseGermanAddress($event);\n    this.germanAddress = germanAddress;\n    if (germanAddress.vicinity) {\n      this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.streetName) {\n      this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.streetNumber) {\n      this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.postalCode) {\n      this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, {emitEvent: false, onlySelf: true});\n    }\n    if (germanAddress.locality && germanAddress.locality.long) {\n      this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, {emitEvent: false, onlySelf: true});\n    }\n\n    this.value = germanAddress;\n    this.onGermanAddressMapped.emit(germanAddress);\n  }\n\n  writeValue(obj: any): void {\n    let shouldRecreateFG = false;\n    if (obj) {\n      if (!this.value && this.firstInit) {\n        shouldRecreateFG = true;\n      }\n      this.value = obj;\n      if (shouldRecreateFG) {\n        this.createAddressFormGroup();\n        this.firstInit = false;\n      }\n    }\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n  }\n\n}\n","<div fxLayout=\"column\">\n  <div *ngIf=\"!disableSearch\" fxFlex=\"100\">\n    <!--search address-->\n    <mat-form-field fxFlex=\"auto\" [appearance]=\"searchBarAppearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n      <mat-label>{{searchAddressLabel}}</mat-label>\n      <input\n        (onAutocompleteSelected)=\"syncAutoComplete($event)\"\n        [country]=\"country\"\n        [placeIdOnly]=\"placeIdOnly\"\n        [strictBounds]=\"strictBounds\"\n        [types]=\"types\"\n        [type]=\"type\"\n        matGoogleMapsAutocomplete\n        matInput\n        required\n      />\n      <mat-icon color=\"primary\" matSuffix>search</mat-icon>\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n    </mat-form-field>\n  </div>\n\n  <form [formGroup]=\"addressFormGroup\" fxFlex fxLayoutGap=\"10px\">\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"80\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNameLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetName\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNumberLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetNumber\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n    </div>\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{postalCodeLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"postalCode\"\n          type=\"number\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field *ngIf=\"showVicinity\" fxFlex=\"auto\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{vicinityLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          matInput\n          formControlName=\"vicinity\"\n        />\n      </mat-form-field>\n      <div formGroupName=\"locality\" fxFlex=\"auto\">\n        <mat-form-field fxFlex=\"auto\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n          <mat-label>{{localityLabel}}</mat-label>\n          <input\n            [readonly]=\"readonly\"\n            formControlName=\"long\"\n            matInput\n            required\n          />\n          <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n        </mat-form-field>\n      </div>\n    </div>\n  </form>\n</div>\n","import {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {FlexLayoutModule} from '@angular/flex-layout';\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport {MatGoogleMapsAutocompleteDirective} from './directives/mat-google-maps-autocomplete.directive';\nimport {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\nimport {MatGoogleMapsAutocompleteComponent} from './component/mat-google-maps-autocomplete.component';\n// tslint:disable-next-line:max-line-length\nimport {MatSearchGoogleMapsAutocompleteComponent} from './component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component';\n\n\n@NgModule({\n  imports:\n    [\n      CommonModule,\n      FormsModule,\n      ReactiveFormsModule,\n      FlexLayoutModule,\n      MatInputModule,\n      MatIconModule\n    ],\n  exports: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective,\n    MatSearchGoogleMapsAutocompleteComponent\n  ],\n  declarations: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective,\n    MatSearchGoogleMapsAutocompleteComponent\n  ]\n})\nexport class MatGoogleMapsAutocompleteModule {\n}\n","/*\n * Public API Surface of google-maps-autocomplete\n */\n\nexport * from './lib/helpers/parser';\nexport * from './lib/interfaces';\nexport * from './lib/component';\nexport * from './lib/directives/mat-google-maps-autocomplete.directive';\nexport * from './lib/directives/address-validator/mat-address-validator.directive';\nexport * from './lib/mat-google-maps-autocomplete.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}}}